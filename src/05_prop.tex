%=====================================================
\section{Our proposed scheme} \label{sec:proposed_scheme}
%=====================================================

There are security concerns and redundant procedures in original
QUIC.
About security concerns, in~\cite{LJBN15:QUIC}, they found five
attacks and these attacks assist the adversary do Distributed
Denial of Service attack.
The main purpose of developing QUIC is to provide an
alternative equivalence of TLS wrapping TCP, with much
reduced latency and better SPDY and HTTP/2 support.
For this purpose, QUIC should prevent these attacks.
About redundant procedures, in other protocol using Diffie-Hellman
such as SIGMA protocol~\cite{Kra03:SIGMA}, HMQV~\cite{Kra05:HQMV},
a client send its Diffie-Hellman public value in a first query. However,
in QUIC, a client send its Diffie-Hellman public value in a second query.
This scheme cause not only redundant latency but also additional assumption
 which is Strong Computational Diffie-Hellman (SCDH) assumption.

To solve above issues, we propose a new scheme which is more secure and efficient
than original QUIC and it satisfy RSACCE secure.
In our proposed scheme, a client sends its Diffie-Hellman public value in
a first query.
This scheme is big difference from original one and it sounds difficult to apply
this modification even if QUIC is still under development.
However, the handshake of QUIC will be replaced TLS1.3 and the handshake scheme of
TLS1.3 is similar to our proposed scheme in terms of that a client sends its
Diffie-Hellman public value in a first query.

In~\cite{LJBN15:QUIC}, they found five attacks:
(1) Server Config Replay Attack,
(2) Source-Address Token Replay Attack,
(3) Connection ID Manipulation Attack,
(4) Source-Address Token Manipulation Attack,
(5) Crypto Stream Offset Attack.
In our proposed scheme, $\STK$ and $\cid$ are authenticated with initial key
$\ik$ and other parameters are also authenticated.
This modification prevents (1)Server Config Replay Attack,
(3) Connection ID Manipulation Attack, and
(4) Source-Address Token Manipulation Attack.
In our proposed scheme, the server ensure the consistency of the client between
a 1-RTT connection and 0-RTT connections, in other words, only the client which
execute full handshake and has matching conversation for initial key and forward
secure key with the server in 1-RTT connection can establish 0-RTT connection with
the server because the client sends MAC generated by $\key_{mac}$ in 0-RTT request.
The client receives a ciphertext which includes $\key_{mac}$ in 1-RTT connection.
This modification prevents (2) Source-Address Token Replay Attack.

%=====================================================
\subsection{1-RTT Connection Establishment} \label{sec:quic_prop_1rtt}
%=====================================================

The abstract model of our proposed scheme is in
Fig.~\ref{fig:quic_prop_1rtt}.

\input{05_z1_proposed_1rtt_overview}

We define three phases of our proposed scheme handshake in 1-RTT:
(1) \textbf{Initiate},
(2) \textbf{Key Agreement},
(3) \textbf{Data Exchange}.

\input{05_prop_01_01_initiate}
\input{05_prop_01_02_key_agr}
\input{05_prop_01_03_data_exchange}

%=====================================================
\subsection{0-RTT Connection Establishment} \label{sec:quic_prop_0rtt}
%=====================================================

The abstract model of our proposed scheme is in
Fig.~\ref{fig:quic_prop_0rtt}.

\input{05_z2_proposed_0rtt_overview}

We define four phases of our proposed scheme handshake in 0-RTT:
(1) \textbf{Initial Key Agreement},
(2) \textbf{Initial Data Exchange},
(3) \textbf{Key Agreement}, and
(4) \textbf{Data Exchange}.
The flow of (4) are the same as the 1-RTT
handshake.

\input{05_prop_02_01_init_key_agr}
\input{05_prop_02_02_init_data_exchange}
\input{05_prop_02_03_key_agr}

%=====================================================
\subsection{Security of our proposed scheme} \label{sec:quic_proof}
%=====================================================

In this section we prove the security of our proposed scheme.

\begin{theorem} \label{theorem:proposed_scheme}
 Let $\mu$ be the output length of $\PRF$, let $\lambda$ be
 the length of $\SCID$, let $\nu$ be the length of mac, let $\nclient$ be the number of
 clients, let $\nserver$ be the number of servers, let
 $\noracle$ be the number of oracles of each parties, and
 let $n_{\ell}$ be the maximum number of 0-RTT connection. Assume
 that the $\PRF$ is $(t, \epsilon_{\prf})$-pseudo-random
 function family, the signature scheme
 $\SIG$ is $(t, \epsilon_{\sig})$-secure against existentially
 unforgeable under adaptive chosen-message attacks, the DDH
 problem on $G$ is $(t, \epsilon_{\ddh})$-hard, the hash
 function family $\mathcal{H}$ is
 $(t,\epsilon_{H})$-collision-resistant (CR), the symmetric
 authenticated encryption scheme $\SE$ is
 $(t, \epsilon_{\LHAE})$-secure.
 Then for all PPT adversaries, our proposed scheme is RSACCE secure.
\end{theorem}

We prove Theorem~\ref{theorem:proposed_scheme} by proving three lemmas.

\begin{lemma} \label{lemma:proposed_scheme_rsacce-sa}
 $\Adv^{\rsaccesa}_{P}(A)$ is at most
 \begin{eqnarray}
  \Adv^{\rsaccesa}_{P}(A) \leq \nclient \noracle \nserver \nresumption
  (\epsilon_{sig} + \noracle (\epsilon_{\ddh} + 2\epsilon_{\prf} + \epsilon_{\LHAE}))
 \end{eqnarray}
\end{lemma}
%
\input{05_z3_proposed_scheme_sa}

\begin{lemma} \label{lemma:proposed_scheme_rsacce-cc}
 $\Adv^{\rsaccecc}_{P}(A)$ is at most
 \begin{eqnarray}
  \Adv^{\rsaccecc}_{P}(A) \leq \Adv^{\rsaccesa}_{P}(A) + \nonumber \\
  (\nclient + \noracle) \nserver \nresumption \{ \nresumption(\epsilon_{\ddh} + 2\epsilon_{\prf} + \epsilon_{\LHAE})
  + \epsilon_{\LHAE} \}
 \end{eqnarray}
\end{lemma}
%
\input{05_z4_proposed_scheme_cc}

\begin{lemma} \label{lemma:proposed_scheme_rsacce-cb}
 $\Adv^{\rsaccecb}_{P}(A)$ is at most
 \begin{eqnarray}
  \Adv^{\rsaccecb}_{P}(A) \leq \nonumber \\
  \nserver \noracle \nresumption \{ \nresumption(\epsilon_{\ddh} + 2\epsilon_{\prf} + \epsilon_{\LHAE}) + \frac{1}{2^{\nu}} \}
 \end{eqnarray}
\end{lemma}
%
\input{05_z5_proposed_scheme_cb}

%=====================================================
\subsection{Security concerns of our proposed scheme} \label{sec:prop_sec_concerns}
%=====================================================

Our proposed scheme prevents the attacks which original QUIC has.
However, there is another security concern in our proposed scheme.
The security concern is that the server has to calculate initial
key $\ik$ whose computational cost is somewhat heavy to respond the
client's request.
At this point the server cannot validate client's IP address since
there are no interactions.
For this property, the adversary who has no ability, cannot see a
transcript and forge it, can add loads to the server sending request
with spoofed IP address.
The server cannot detect the IP spoofing and has to respond this query.
This problem is caused by not only our proposed scheme but also TLS 1.3
or other protocol which a client send its Diffie-Hellman public value
in a first query.
However, it is only the problem in QUIC since TLS 1.3 is defined on TCP.
We needs to solve this problem before applying TLS 1.3 to QUIC.

We also suggest solution for this problem that add a restriction to our
proposed scheme.
If the server has more specific number connections, the server
responds to a first client's query with a rejection (REJ) which
is the same as a rejection in original QUIC and
fall back to a protocol similar to original QUIC that we call
modified QUIC.
The handshake of the modified QUIC is mixed original QUIC and our
proposed scheme.
The handshake of modified QUIC in 0-RTT is the same as our proposed
scheme.
The difference in a 1-RTT connection between original QUIC and modified one
is that the way to make $\STK$. In modified QUIC, $\STK$ is generated
by the same way as our proposed scheme. The client needs to send
MAC generated by $\key_{MAC}$ in 0-RTT request.
This modification prevents Source-Address Token Replay Attack
in the same way as our proposed scheme.