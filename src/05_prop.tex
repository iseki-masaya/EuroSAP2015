%=====================================================
\section{Our proposed scheme} \label{sec:proposed_scheme}
%=====================================================

There are security concerns and redundant procedures in the original
QUIC.

As for the security concerns,
Lychev~\cite{LJBN15:QUIC} pointed out five attacks,
which may lead to the Distributed Denial of Service (DDoS) attacks.
As described above,
the DDoS attacks take advantage of either incomplete server-authentication or
lack of channel binding.
In the RSACCE model, the attacks in \cite{LJBN15:QUIC} do not work.

To improve efficiency of QUIC, we can learn from
the previous protocols such as SIGMA protocol~\cite{Kra03:SIGMA} and HMQV~\cite{Kra05:HQMV},
where a client sends its DH public value in the very first query.
This technique improves not only the number of interactions
but also makes assumptions weaker.

\if0
The main purpose of developing QUIC is to provide an
alternative equivalence of TLS wrapping TCP, with much
reduced latency and better SPDY and HTTP/2 support.
Considering the primary purpose, QUIC must be improved to stand against these DDoS attacks.
\fi

\if0
To solve above issues, we propose a new scheme which is more secure and more efficient
than the original QUIC and it satisfy RSACCE secure.
In our proposed scheme, a client sends its DH public key in
a first query.
% This scheme is big difference from original one and it sounds difficult to apply
% this modification even if QUIC is still under development.
% The handshake of QUIC will be replaced TLS1.3.
% However
%  and the handshake scheme of
% TLS1.3 is similar to our proposed scheme in terms of that a client sends its
% DH public key in a first query.
\fi

\if0
In~\cite{LJBN15:QUIC}, they found five attacks:
(1) Server Config Replay Attack,
(2) Source-Address Token Replay Attack,
(3) Connection ID Manipulation Attack,
(4) Source-Address Token Manipulation Attack,
(5) Crypto Stream Offset Attack.
In our proposed scheme, $\STK$ and $\cid$ are authenticated with the initial key
$\ik$ and other parameters are also authenticated.
This modification prevents (1)Server Config Replay Attack,
(3) Connection ID Manipulation Attack, and
(4) Source-Address Token Manipulation Attack.
In our proposed scheme, the server ensure the consistency of the client between
a 1-RTT connection and 0-RTT connections, in other words, only the client which
execute full handshake and has matching conversations for an initial key and forward
secure key with the server in 1-RTT connection can establish 0-RTT connection with
the server because the client sends MAC generated by $\key_{mac}$ in 0-RTT request.
The client receives a ciphertext which includes $\key_{mac}$ in 1-RTT connection.
This modification prevents (2) Source-Address Token Replay Attack.
\fi
%=====================================================
\subsection{1-RTT Connection Establishment} \label{sec:quic_prop_1rtt}
%=====================================================

The abstract model of our proposed scheme is in
Fig.~\ref{fig:quic_prop_1rtt}.

\input{05_z1_proposed_1rtt_overview}

We define three phases of our proposed scheme handshake in 1-RTT:
(1) \textbf{Initiate},
(2) \textbf{Key Agreement},
(3) \textbf{Data Exchange}.

\input{05_prop_01_01_initiate}
\input{05_prop_01_02_key_agr}
\input{05_prop_01_03_data_exchange}

%=====================================================
\subsection{0-RTT Connection Establishment} \label{sec:quic_prop_0rtt}
%=====================================================

The abstract model of our proposed scheme is in
Fig.~\ref{fig:quic_prop_0rtt}.

\input{05_z2_proposed_0rtt_overview}

We define four phases of our proposed scheme handshake in 0-RTT:
(1) \textbf{Initial Key Agreement},
(2) \textbf{Initial Data Exchange},
(3) \textbf{Key Agreement}, and
(4) \textbf{Data Exchange}.
The flow of (4) are the same as the 1-RTT
handshake.

\input{05_prop_02_01_init_key_agr}
\input{05_prop_02_02_init_data_exchange}
\input{05_prop_02_03_key_agr}

%=====================================================
\subsection{Security of our proposed scheme} \label{sec:quic_proof}
%=====================================================

In this section we prove the security of our proposed scheme.

\begin{theorem} \label{theorem:proposed_scheme}
 Let $\mu$ be the output length of $\PRF$, let $\lambda$ be
 the length of $\SCID$, let $\nu$ be the length of mac, let $\nclient$ be the number of
 clients, let $\nserver$ be the number of servers, let
 $\noracle$ be the number of oracles of each parties, and
 let $n_{\ell}$ be the maximum number of 0-RTT connection. Assume
 that the $\PRF$ is $(t, \epsilon_{\prf})$-pseudo-random
 function family, the signature scheme
 $\SIG$ is $(t, \epsilon_{\sig})$-secure against existentially
 unforgeable under adaptive chosen-message attacks, the DDH
 problem on $G$ is $(t, \epsilon_{\ddh})$-hard, the hash
 function family $\mathcal{H}$ is
 $(t,\epsilon_{H})$-collision-resistant (CR), the symmetric
 authenticated encryption scheme $\SE$ is
 $(t, \epsilon_{\LHAE})$-secure.
 Then for all PPT adversaries, our proposed scheme is RSACCE secure.
\end{theorem}

We prove Theorem~\ref{theorem:proposed_scheme} by proving three lemmas.
Lemma~\ref{lemma:proposed_scheme_rsacce-sa} is about \textit{server authentication}.
In this proof, finally we randomize $\ik$ in the target server oracle.
$\ik$ is used to encrypt the server's ephemeral DH public
key. The adversary has to generate correct $\ik$ to make the client accept
the forged query. If the client accepts with the forged query, the adversary
break the server authentication.
Lemma~\ref{lemma:proposed_scheme_rsacce-cc} is about \textit{channel confidentiality}.
In this proof, we need to randomize not only $\ik$ and $\key$ of the target oracles
but also $\ik$ and $\key$ of oracles which execute 0-RTT request before the target
oracles. We repeat the game until randomizing all $\ik$ and $\key$ of the oracles.
Lemma~\ref{lemma:proposed_scheme_rsacce-cc} is about \textit{channel binding}.
This proof is similar to the proof of channel confidentiality. In this proof, we need
to randomize $\ik$ of the target oracles and $\ik$ and $\key$ of oracles which execute
0-RTT request before the target oracle.

\begin{lemma} \label{lemma:proposed_scheme_rsacce-sa}
 $\Adv^{\rsaccesa}_{P}(A)$ is at most
 \begin{eqnarray}
  \Adv^{\rsaccesa}_{P}(A) \leq \nclient \noracle \nserver \nresumption
  (\epsilon_{sig} + \noracle (\epsilon_{\ddh} + 2\epsilon_{\prf} + \epsilon_{\LHAE}))
 \end{eqnarray}
\end{lemma}
%
\input{05_z3_proposed_scheme_sa}

\begin{lemma} \label{lemma:proposed_scheme_rsacce-cc}
 $\Adv^{\rsaccecc}_{P}(A)$ is at most
 \begin{eqnarray}
  \Adv^{\rsaccecc}_{P}(A) \leq \Adv^{\rsaccesa}_{P}(A) + \nonumber \\
  (\nclient + \noracle) \nserver \nresumption \{ \nresumption(\epsilon_{\ddh} + 2\epsilon_{\prf} + \epsilon_{\LHAE})
  + \epsilon_{\LHAE} \}
 \end{eqnarray}
\end{lemma}
%
\input{05_z4_proposed_scheme_cc}

\begin{lemma} \label{lemma:proposed_scheme_rsacce-cb}
 $\Adv^{\rsaccecb}_{P}(A)$ is at most
 \begin{eqnarray}
  \Adv^{\rsaccecb}_{P}(A) \leq \nonumber \\
  \nserver \noracle \nresumption \{ \nresumption(\epsilon_{\ddh} + 2\epsilon_{\prf} + \epsilon_{\LHAE}) + \frac{1}{2^{\nu}} \}
 \end{eqnarray}
\end{lemma}
%
Due to spaces, we omit the detailed proofs of the Lemmas.
This proof is similar to the proof of channel confidentiality.

%=====================================================
\subsection{Security concerns of our proposed scheme} \label{sec:prop_sec_concerns}
%=====================================================

Our proposed scheme prevents the attacks which the original QUIC has.
However, there are another security concerns in our proposed scheme.
This security concerns are the same as the problem DTLS\cite{DTLS12}
has and these are: (1) an adversary can consume excessive resources
on the server by transmitting a series of handshake initiation requests,
causing the server to allocate state and potentially to perform expensive
cryptographic operations, (2) an adversary can use the server as an
amplifier by sending connection initiation message with a forged source
of the victim. The server then sends its next message to the victim
machine.
About the first issue, in a first client request, the server cannot validate
client's IP address since there are no interactions.
For this property, the adversary who cannot see a
transcript and forge it can increase the server loads sending request
with the spoofed IP address.
The second issue is called Distributed Reflection Denial of Service
(DRDoS) and Christian~\cite{Ross14} proposed some countermeasures against it.
We can apply the countermeasure of DTLS to our proposed scheme.
However, this countermeasure needs additional interactions and eliminates
the advantage of our propose scheme which reduce interactions.

We suggest another solution for the first issue that add a restriction to our
proposed scheme.
If the server has more specific number connections, the server
responds to a first client's query with a rejection (REJ) which
is the same as a rejection in the original QUIC and
fall back to a protocol similar to the original QUIC that we call
modified QUIC.
The handshake of the modified QUIC is mixed the original QUIC and our
proposed scheme.
The handshake of modified QUIC in 0-RTT is the same as our proposed
scheme.
The difference in a 1-RTT connection between the original QUIC and modified one
is that the way to make $\STK$. In modified QUIC, $\STK$ is generated
by the same way as our proposed scheme. The client needs to send
MAC generated by $\key_{MAC}$ in 0-RTT request.
This modification prevents Source-Address Token Replay Attack
in the same way as our proposed scheme.