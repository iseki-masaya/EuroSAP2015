%=====================================================
\section{Quick UDP Internet Connections} \label{sec:quic}
%=====================================================

Quick UDP Internet Connections (QUIC) is a protocol
developed by Google and this protocol is still under
development.
The concepts of QUIC are (1) to reduce connectivity
overheads before a client sends encrypted data and
(2) to obtain better security guarantee than TLS.
To realize concept (1), QUIC is not defined over
TCP but UDP, because TCP requires three-move handshake
before initiating a cryptographic handshake, but UDP
does not have. In addition, a client can send encrypted
data concurrently with CHLO which is second query of the
client.
To realize concept (2), QUIC supports only secure cipher
suites. Especially, a support algorithm of key exchange
is only ephemeral elliptic curve Diffie-Hellman.

There are two type connections, 1 round trip time (RTT)
connection and 0 round trip time connection, in QUIC.
The former case is called 1-RTT connection, the latter
case is called 0-RTT connection.
The first time a client connects to a server, the client
must perform 1-RTT handshake to acquire a necessary
information

%=====================================================
\subsection{1-RTT Connection Establishment} \label{sec:quic_1rtt}
%=====================================================

We provide the abstract model of QUIC for 1-RTT in
Fig.~\ref{fig:quic_abst_1rtt}.
%
\input{04_z1_protocol_1rtt_overview}
%
We define five phases of QUIC handshake in 1-RTT:
(1) \textbf{Initiate},
(2) \textbf{Initial Key Agreement},
(3) \textbf{Initial Data Exchange},
(4) \textbf{Key Agreement}, and
(5) \textbf{Data Exchange}.

\input{04_quic_01_01_initiate}
\input{04_quic_01_02_init_key_agr}
\input{04_quic_01_03_init_data_exchange}
\input{04_quic_01_04_key_agr}
\input{04_quic_01_05_data_exchange}

%=====================================================
\subsection{0-RTT Connection Establishment} \label{sec:quic_0rtt}
%=====================================================

We provide the abstract model of QUIC for 0-RTT in
Fig.~\ref{fig:quic_abst_0rtt}.
%
\input{04_z2_protocol_0rtt_overview}
%
We define four phases of QUIC handshake in 0-RTT:
(1) \textbf{Initial Key Agreement},
(2) \textbf{Initial Data Exchange},
(3) \textbf{Key Agreement}, and
(4) \textbf{Data Exchange}.
The flow of (2), (3), (4) are the same as the 1-RTT
handshake.

\input{04_quic_02_01_init_key_agr}

%=====================================================
\subsection{Security of QUIC} \label{sec:quic_detail}
%=====================================================

In~\cite{LJBN15:QUIC}, they found five attacks:
(1) Server Config Replay Attack,
(2) Source-Address Token Replay Attack,
(3) Connection ID Manipulation Attack,
(4) Source-Address Token Manipulation Attack,
(5) Crypto Stream Offset Attack.

These attacks assist the adversary do Distributed Denial of Service
(DDoS) attack.

The adversary make a client and server share a different
initial key $\ik$ using (1), (3), and (4).
These attacks break server authentication because the client
reaches accept state and there are no server oracle which has
matching conversation for initial key with the client oracle in 1-RTT connection.
The adversary make a server accept in 0-RTT connection
using (2).
This attack breaks channel confidentiality because the adversary
can share the session key with the target server.
We do not consider the attack (5) because this attack is not
about handshakes.

For more details about (1), (3) and (4), the adversary can forge
$\STK$ and $\cid$ because there are no authentication mechanism
for these parameters.
The server generate signature for $\SCFG$, however, the generation
of $\SCFG$ is independent from client's first query and these parameters
which generated at client's first query
are not certificated and even authenticated.
If the adversary forge these parameters, the client and server cannot
detect it.

For more details about (2), although QUIC has a mechanism to prevent forgery,
whose mechanisms is called \textit{source-address token}
(see below), the adversary can forge an abbreviate handshake
query as follows: An adversary can obtain $\SCID$ and $\STK$ from $\REJ$
response, which is the first response from a server oracle.
Then, the adversary make $(\overline{T}_c^{\prime},
\overline{\NONC}^{\prime}, \overline{\cid})$ and send $(\overline{T}_c^{\prime},
\SCID, \overline{\NONC}^{\prime}, \STK, \overline{\cid})$ to the server after a
full handshake between the server and its intended partner
is established.
The server cannot distinguish whether the query in an abbreviate handshake
comes from the intended partner or not. Because there is no
authentication mechanism for this query. The server accepts
this query and calculates the session keys with the value
of the adversary.

If the protocol meets RSACCE secure, the protocol prevents these attacks (1)~(4).

\subsubsection{Source Address Token} \label{sec:source_address_token}
Source-address token ($\STK$) is introduced to QUIC in order to
prevent IP address spoofing.
A server generates and sends a new STK every time he sends a
message to a client.
The client updates STK when the client receives a new one from
the server and sends it back along with his message.
$\STK$ is an opaque byte string from the client's point of view.
From the server's point of view it's an authenticated-encryption
block that contains, at least, the client's IP address and a time
stamp by the server.
$\STK$ is encrypted except for the first server's query ($\REJ$).
However, in our model the adversary has full control over the
communication network and hence it can obtain $\STK$ and use it to
forge a future query.