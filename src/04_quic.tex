%=====================================================
\section{Quick UDP Internet Connections} \label{sec:quic}
%=====================================================

Quick UDP Internet Connections (QUIC) is a protocol
developed by Google and this protocol is still under
development.
The concepts of QUIC are (1) to reduce connectivity
overheads before a client sends encrypted data and
(2) to obtain better security guarantee than TLS.
To realize concept (1), QUIC is not defined over
TCP but UDP, because TCP requires three-move handshake
before initiating a cryptographic handshake, but UDP
does not have. In addition, a client can send encrypted
data concurrently with CHLO which is second query of the
client.
To realize concept (2), QUIC supports only secure cipher
suites. Especially, a support algorithm of key exchange
is only ephemeral elliptic curve Diffie-Hellman.

There are two type connections, 1 round trip time (RTT)
connection and 0 round trip time connection, in QUIC.
The former case is called 1-RTT connection, the latter
case is called 0-RTT connection.
The first time a client connects to a server, the client
must perform 1-RTT handshake to acquire a necessary
information

%=====================================================
\subsection{1-RTT Connection Establishment} \label{sec:quic_1rtt}
%=====================================================

We provide the abstract model of QUIC for 1-RTT in
Fig.~\ref{fig:quic_abst_1rtt}.
%
\input{04_z1_protocol_1rtt_overview}
%
A server generate server config $\SCFG$ before a request from a client.
We describe the detail of generation of $\SCFG$ in \label{sec:proposed_scheme}.
SCFG is composed of seven parameters AEAD, SCID, PDMD,
PUBS, KEXS, and OBIT, and EXPY. The important parameters
are SCID which is an opaque 16 byte identifier for
this server config, PUBS which is server's
Diffie-Hellman public value, and EXPY which is expiry time
for this server config. The details of other parameters
are described in~\cite{QUIC:Crypto}.
Our definition consider only important parameters.

Firstly, the client sends an inchoate client
hello ($m_1$) which contains connection id
and some information such as server name, protocol
version, and user agent id. In our definition,
the some informations are omitted.

After the server receives inchoate client hello, it
sends a rejection ($m_2$). The rejection ($m_2$) contains
source address token (STK), server config ($\SCFG$) which
include a signature $\sigma_s$ of the server config generated
by the server long term secret key $sk_s$. The client use
STK in future queries to demonstrate ownership of their
source IP address.

After the client receives a rejection ($m_2$), the client
checks the server config $\SCFG$ and generate $\NONC$ which consists
of a random value, and ephemeral
Diffie-Hellman values $t_c$.
The client sends a client hello ($m_3$) to the server.

After the server receives a client hello ($m_3$), the
server check this query. $\STK$ is an opaque byte string
from the client's point of view. From the server's point
of view it's an authenticated-encryption block that
contains, at least, the client's IP address and a time
stamp by the server. The server decrypt $\STK$ and
validate time and source IP address.

After sharing initial key $\ik$, the client and server
exchange data encrypted and authenticated using Length-Hiding
Authenticated Encryption $\SE$ with initial key $\ik$.

The server send a server hello ($m_4$) which contains
a ciphertext which consists of a new $\STK$ and ephemeral server's
Diffie-Hellman public value after exchanging data and
calculate last key $\key$.

The client validate a server hello ($m_4$) and calculate
last key $\key$ and cache the data.

%=====================================================
\subsection{0-RTT Connection Establishment} \label{sec:quic_0rtt}
%=====================================================

We provide the abstract model of QUIC for 0-RTT in
Fig.~\ref{fig:quic_abst_0rtt}.
%
\input{04_z2_protocol_0rtt_overview}
%
Firstly, the client sends a client hello using cache data.
The server searches $\SCFG$ with $\SCID$ and validate a
client hello.
After the client sends a client hello or the server validate
a client hello, they calculate initial key $\ik$.
The flow for last key $\key$ is the same as
1-RTT case.


%=====================================================
\subsection{Security of QUIC} \label{sec:quic_detail}
%=====================================================

In~\cite{LJBN15:QUIC}, they found five attacks:
(1) Server Config Replay Attack,
(2) Source-Address Token Replay Attack,
(3) Connection ID Manipulation Attack,
(4) Source-Address Token Manipulation Attack,
(5) Crypto Stream Offset Attack.

These attacks enable the adversary to do Distributed Denial of Service
(DDoS) attack.

The adversary make a client and server share a different
initial key $\ik$ using (1), (3), and (4).
These attacks break server authentication because the client
reaches accept state and there are no server oracle which has
matching conversation for initial key with the client oracle in 1-RTT connection.
The adversary make a server accept in 0-RTT connection
using (2).
This attack breaks channel confidentiality because the adversary
can share the session key with the target server.
We do not consider the attack (5) because this attack is not
about handshakes.

For more details about (1), (3) and (4), the adversary can forge
$\STK$ and $\cid$ because there are no authentication mechanism
for these parameters.
The server generate signature for $\SCFG$, however, the generation
of $\SCFG$ is independent from client's first query and these parameters
which generated at client's first query
are not certificated and even authenticated.
If the adversary forge these parameters, the client and server cannot
detect it.

For more details about (2), although QUIC has a mechanism to prevent forgery,
whose mechanisms is called \textit{source-address token}
(see below), the adversary can forge an abbreviate handshake
query as follows: An adversary can obtain $\SCID$ and $\STK$ from $\REJ$
response, which is the first response from a server oracle.
Then, the adversary make $(\overline{T}_c^{\prime},
\overline{\NONC}^{\prime}, \overline{\cid})$ and send $(\overline{T}_c^{\prime},
\SCID, \overline{\NONC}^{\prime}, \STK, \overline{\cid})$ to the server after a
full handshake between the server and its intended partner
is established.
The server cannot distinguish whether the query in an abbreviate handshake
comes from the intended partner or not. Because there is no
authentication mechanism for this query. The server accepts
this query and calculates the session keys with the value
of the adversary.

If the protocol satisfies RSACCE secure, the protocol prevents these attacks (1)~(4).

\subsubsection{Source Address Token} \label{sec:source_address_token}
Source-address token ($\STK$) is introduced to QUIC in order to
prevent IP address spoofing.
A server generates and sends a new STK every time he sends a
message to a client.
The client updates STK when the client receives a new one from
the server and sends it back along with his message.
$\STK$ is an opaque byte string from the client's point of view.
From the server's point of view it's an authenticated-encryption
block that contains, at least, the client's IP address and a time
stamp by the server.
$\STK$ is encrypted except for the first server's query ($\REJ$).
However, in our model the adversary has full control over the
communication network and hence it can obtain $\STK$ and use it to
forge a future query.